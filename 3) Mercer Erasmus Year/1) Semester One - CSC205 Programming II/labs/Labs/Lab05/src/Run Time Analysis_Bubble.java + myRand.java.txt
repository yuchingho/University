	Run Time Analysis

First off, we want to write a program MyRand which will create two data sets of random integers of sizes 10,000 and 40,000.
To do this, create a for loop that will run size times where size is an integer typed at the command line upon execution. In the body of that loop, write one line of code which will print a random integer between 1 and 500 to the screen for each loop iteration. Your sequence should be inclusive (i.e. include the 500). Make sure you'll be printing each number on a separate line.

Compile this program, and run it using the command :"java MyRand 10000 > data1"
 
This instructs the operating system to send all output to the file data1 rather than the screen.  
Edit the file data1 and make sure it contains 10,000 random integers in your desired range.

Now, re-run your program using a command that will give us a file of 40,000 integers: "java MyRand 40000 > data2"
 
Now, let's determine the actual amount of system run-time that it takes to sort the data from both of our files using the bubble sort algorithm (an algorithm). 
To do this, we need to use the Linux time command. This command will return the time in seconds that it takes the CPU to complete your program.

The program Bubble is an executable program which reads in integers from the keyboard, and sorts them using the bubble sort algorithm. This program is set up to take the desired array size you plan on sorting from the command line.  So, here is the command we need to type to calculate the run time of a bubble sort on an array of size 10,000 is: "time java Bubble 10000 < data1"

The total time it takes this to run will be the first float value on the first line prior to ``user." It should be around two seconds to sort 10,000 integers using a bubble sort.  Create a table below to record your predicted and actual results.

Now, before we run our program on our array of size 40,000, let's see if we can  predict our run-time.  Remember to predict the run-time, you simply need to look at the factor of input increase, plug this increase into your growth rate (ours is   with the bubble sort), and then multiply this value by your prior run-time.  Fill in your predicted value for 40,000 in the table.

Repeat the timing process now on your array of size 40,000.  
Record your result in your table.  
How close were your predicted and actual values? 

Finally, delete your two data files, data1 and data2.  They’re both very large files that we’ll no longer need, and can easily recreate if we do.

Run-Time Analysis explanation
Run time Analysis was based on our in class Run Time Notation worksheet.  Once we set how we could determine the growth rate of an algorithm as O(n), O(log n), O(n^2), we saw how as you increase the amount of input n, you increase the run time.  The Run Time Analysis helped you see this in action by looking at the exact time it took us to run a piece of software.